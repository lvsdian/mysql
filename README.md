[TOC]

### 事物

- 事务是逻辑上的一组操作，要么都执行，要么都不执行。
- 四个特性：
  
  - **原子性**： 事务是最小的执行单位，不允许分割。
  
  - **一致性**：执行事务前后，数据保持一致。
  
  - **隔离性**：并发访问数据库时，一个用户的事务不被其他事务所干扰。
  - **持久性**： 一个事务被提交之后。它对数据库中数据的改变是持久的。
- 并发事物带来的问题：

  - **脏读**：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。

  - **不可重复读**：在一个事务还没有结束时，另一个事务也访问该数据，并且做了修改(update/delete)。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。

  - **幻读(虚读)**：它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
- 隔离级别
  - **READ-UNCOMMITTED(读取未提交)：**允许读取尚未提交的数据变更。
  - **READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据。
  - **REPEATABLE-READ(可重复读)：**mysql默认级别， 对同一字段的多次读取结果都是一致的。
  - **SERIALIZABLE(可串行化)：** 最高的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。


### 存储引擎

- 存储引擎是数据库底层的软件组织，数据库管理系统通过存储引擎进行增删查改。存储引擎主要有InnoDB、MyISam、Memory、Archive等。
- mysql5.5之前默认使用MyISam为默认存储引擎，5.7开始采用InnoDB为默认存储引擎。  
查看mysql提供的所有存储引擎：`show engines;`  
查看默认存储引擎：`show variables like '%storage_engine%';`  
查看具体某个表的存储引擎：`show table status like "table_name";`  

- InnoDB与MyISam不同之处：

  1. **锁**：InnoDB支持行级锁(row-level locking)和表级索(table-level locking)，默认行级锁；MyISam只支持表级索。

  2. **事务、崩溃后恢复**：MyISam查询具有原子性，速度比InnoDb快，但不支持事务；InnoDb提供事务支持事务，具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

  3. **是否支持外键**： MyISAM不支持，而InnoDB支持。

  4. **MVCC**：即多版本并发控制，InnoDB支持，MyISam不支持。

#### MVCC

- mvcc是一种提高并发的技术，只在读已提交和重复读两个隔离级别下工作，不同的数据库对mvcc的实现不统一，即可以使用悲观锁来实现也可以使用乐观锁来实现。一般MVCC有2种实现方法：
	- 写新数据时，把旧数据转移到一个单独的地方，比如mysql，oracle。
	- 写新数据时，旧数据不删除，而是把新数据插入，比如PostgreSQL。
	
- 在InnoDB的实现中，InnoDB向数据库的每一行添加三个隐藏字段：
	- 6字节的DB_TRX_ID：事务ID。标识最近一次对本行记录做修改的事务的标识符
	- 7字节的DB_ROLL_PTR：回滚指针。指向当前记录项的undo信息。
	- 6字节的DB_ROW_ID：随着新行插入单调递增的一个字段。当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，不然的话聚集索引中不包括这个值。

	​        当一个事物更改某行数据时，就会用排它锁锁定该行，修改当前行的值，填写事物编号，并且把当前行的值拷贝到一个叫undo log的表中，使回滚指针指向undo log中修改的当前行，当另外一个事物也对当前行操作时，就会通过来控制数据的版本。
	
	[参考一](https://segmentfault.com/a/1190000012650596)
	      
	[参考二](https://github.com/zhangyachen/zhangyachen.github.io/issues/68)

### 索引

- 索引是排好序的快速查找的数据结构。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上。索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

- 优缺点：
  - 降低数据库IO成本；降低CPU消耗。
  - 提高查询速度，但降低了增删改的速度；索引自身是保存了主键和索引列字段的表，也需要占空间。

- 分类：

  - 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。
  - 复合索引：即一个索引包含多个列。
  - 唯一索引：索引列的值必须唯一，但允许有空值。
- 覆盖索引：索引列包含了查询的字段。
  - **聚簇(集)索引**：数据行的物理顺序与列值(一般是主键那一列)的逻辑顺序一致，并且叶节点就是数据结点。一张表只能有一个聚簇索引。
- **非聚簇(集)索引**：索引的逻辑顺序与数据行的物理存储顺序不一致，叶节点有指针指向数据块，需进行二次查询，一张表能有多个非聚簇索引。
  
 #### B-Tree、B+Tree

  - 平衡二叉树缺点：
    - 如果节点很多的话，那么这个AVL树的高度还是会很高的，那么查询效率还是会很低。
    
    - 查询的效率不稳定，还是会有看运气的成分在里面。
    
    - 维护平衡过程的成本代价很高。因为每次删除一个节点或者增加一个节点的话，需要一次或者多次的左旋，右旋等去维护“平衡”状态。
    
    - 节点存储的数据内容太少。没有很好利用操作系统和磁盘数据交换特性，也没有利用好磁盘IO的预读能力。
- 2-3树
  - 2-3树是一种多路查找树，2和3的意思是2-3树包含两种结点：
    - 2结点包含一个元素和两个孩子(或者没有孩子)。左子树的结点的元素值小于该结点的元素值；右子树的结点的元素值大于该结点的元素值。
    - 3结点包含一大一小两个元素和三个孩子(或者没有孩子)。左子树的结点的元素值小于该结点较小的元素值；右子树的结点的元素值大于该结点较大的元素值。
    - 2-3树的所有叶子结点都在同一层次上。
    

<div align="center"> <img src="img/2-3树.png"/> </div><br>

- 2-3-4树类推

  <div align="center"> <img src="img/2-3-4树.png"/> </div><br>

- B树
  - B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。树中结点的最大孩子数为树的阶，通常记为m，2-3树的阶为3,2-3-4树的阶为4。
    - 树中每个结点至多有m颗子树。(即至多含m-1个关键字，两棵子树指针夹着一个关键字)。
    - 若根结点不是终端结点，则至少有两个子树。(至少一个关键字)
    - 除根节点外的所有非叶结点至少有[m/2]棵子树。(至少有[m/2]-1个关键字，[m/2]表示m/2向上取整)
    - 所有叶子结点出现在同一层次上。

